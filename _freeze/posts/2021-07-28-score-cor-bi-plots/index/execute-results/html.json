{
  "hash": "3019bbdaf6e5a9b4f0816827a1b1daee",
  "result": {
    "markdown": "---\ntitle: Plotting Multivariate Analyses with ggplot2\nsubtitle: 'Score, loading, correlation, and bi-plots with ggplot2 and friends'\n# author: Eric R. Scott\ndate: '2021-02-08'\ncategories:\n  - multivariate-statistics\n  - data-visualization\n  - r\ndraft: true\n---\n\n\n-   what score, loading, correlation, bi-plots are (rely heavily on links as this post focused on plotting)\n-   use palmer penguins dataset\n-   how to find data for plots in model objects (one or two examples)\n-   wide to long\n-   95% CI ellipse\n-   convex hull\n-   labeled arrows\n-   axis labels w/ `glue`\n\nThere are a lot of different methods available for projecting multivariate data onto a few axes that capture most of the variation (or co-variation) in the data.\nExamples include PCA, NMDS, RDA, PLS, and many more acronyms.\nVisualizing results from all of these methods share some things in common, but not enough in common that there exists a single R package that can generate good looking plots for all the multivariate analysis packages in existence.\nOften, packages will have a `plot()` method that produces a (usually fairly ugly) base R score plot, loading plot, or maybe even a biplot.\nThe results of `plot()` aren't R objects that can be easily manipulated or customized though, so you're often left to re-create plots from scratch if you want to make something publication quality.\nThis is a guide to my general approach for creating score plots and loading plots resulting from any sort of multivariate analysis\\^\\*\\^ using `ggplot2` and a few other packages that extend `ggplot2`.\n\n\\*This only includes analyses that involve projecting data onto new axes.\nPERMANOVA, for example, has no natural way to plot results.\n\n# Dataset\n\nAs an example dataset, I'll use the [`palmerpenguins` package](https://allisonhorst.github.io/palmerpenguins/).\nIt contains data on bill length and depth, flipper length, and body mass of different penguin species.\nWe'll do PCA on these variables to see if it separates species.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\nhead(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex    year\n  <fct>   <fct>              <dbl>         <dbl>       <int>   <int> <fct> <int>\n1 Adelie  Torgersen           39.1          18.7         181    3750 male   2007\n2 Adelie  Torgersen           39.5          17.4         186    3800 fema…  2007\n3 Adelie  Torgersen           40.3          18           195    3250 fema…  2007\n4 Adelie  Torgersen           NA            NA            NA      NA <NA>   2007\n5 Adelie  Torgersen           36.7          19.3         193    3450 fema…  2007\n6 Adelie  Torgersen           39.3          20.6         190    3650 male   2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n```\n:::\n:::\n\n\n# The analysis\n\nThere are many forms of multivariate data analysis, but one of the most common (at least in my field) is principal components analysis, an unsupervised method that calculates principal components or axes that represent linear combinations of correlated variables.\nThe data are then projected onto these new axes as \"scores\".\nRead more here...\n\nThere are many ways of doing PCA in R (many of which are listed [here](https://cran.r-project.org/web/views/Multivariate.html)).\nI'm going to focus on the base R `prcomp()` and `rda()` from the `vegan` package as examples, but the idea is to give you a workflow that you can apply to whatever package you're using and whatever multivariate analysis you're using to plot your results.\n\n## With prcomp()\n\nFirst, let's do the PCA and take a look at the plots already available through base R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.1     ✔ purrr   1.0.1\n✔ tibble  3.2.0     ✔ dplyr   1.1.0\n✔ tidyr   1.3.0     ✔ stringr 1.5.0\n✔ readr   2.1.4     ✔ forcats 1.0.0\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\n# remove NAs\npenguins <- penguins %>% filter(!is.na(bill_length_mm))\n#just use morphological variables\nX <- penguins %>% \n  select(bill_length_mm:body_mass_g)\nout_prcomp <- prcomp(X, scale. = TRUE)\nout_prcomp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStandard deviations (1, .., p=4):\n[1] 1.6594442 0.8789293 0.6043475 0.3293816\n\nRotation (n x k) = (4 x 4):\n                         PC1          PC2        PC3        PC4\nbill_length_mm     0.4552503 -0.597031143 -0.6443012  0.1455231\nbill_depth_mm     -0.4003347 -0.797766572  0.4184272 -0.1679860\nflipper_length_mm  0.5760133 -0.002282201  0.2320840 -0.7837987\nbody_mass_g        0.5483502 -0.084362920  0.5966001  0.5798821\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbiplot(out_prcomp)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThe plot produced by `biplot()` shows scores represented as rownumbers, I think, and it's incredibly messy and bascially impossible to read.\nWe can do *a lot* better than this!\n\nIn this case the data we need to reproduce this plot is in the `out_prcomp` object.\nWhat we're looking for is scores to plot the position of the observations along PC1 and PC2 and loadings, to plot arrows showing how the axes are related to the variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(out_prcomp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sdev\"     \"rotation\" \"center\"   \"scale\"    \"x\"       \n```\n:::\n:::\n\n\n`out_prcomp`, like many R objects, is really just a list.\nWe can look at each of the elements and see that `out_prcomp$rotation` and `out_prcomp$x` are both matrixes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout_prcomp$rotation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                         PC1          PC2        PC3        PC4\nbill_length_mm     0.4552503 -0.597031143 -0.6443012  0.1455231\nbill_depth_mm     -0.4003347 -0.797766572  0.4184272 -0.1679860\nflipper_length_mm  0.5760133 -0.002282201  0.2320840 -0.7837987\nbody_mass_g        0.5483502 -0.084362920  0.5966001  0.5798821\n```\n:::\n:::\n\n\nThe `rotation` dataframe is clearly the loadings since the rownames are the variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(out_prcomp$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           PC1         PC2        PC3        PC4\n[1,] -1.840748 -0.04763243  0.2324536  0.5231365\n[2,] -1.304850  0.42772154  0.0295191  0.4018377\n[3,] -1.367178  0.15425039 -0.1983816 -0.5272343\n[4,] -1.876078  0.00204541  0.6176912 -0.4776785\n[5,] -1.908951 -0.82799642  0.6855795 -0.2071241\n[6,] -1.760446  0.35096537 -0.0276311  0.5039784\n```\n:::\n:::\n\n\nThe `x` matrix holds the scores, with each row being a different observation (penguin) and the columns are the coordinates for those observations projected onto the principal component axes.\n\n### Score Plot\n\nLet's start with the scores.\nMy goal here is to start by plotting points on the first two principal components.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscores <- as.data.frame(out_prcomp$x)\n\nggplot(scores) +\n  geom_point(aes(x = PC1, y = PC2))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nNow, it would be nice if we could look for any structure in the data.\nTo do this, we need to join the scores to the raw data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscores_data <- bind_cols(penguins, scores)\npca <- \n  ggplot(scores_data, aes(x = PC1, y = PC2, color = species)) +\n  geom_point()\npca\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nNow let's add some info to the axis labels.\nTypically, axis labels for PCA and other similar methods will show what percentage of the variation in the data is explained by the axis parenthetically.\nWe can see that info in the `summary()` of our PCA.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(out_prcomp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nImportance of components:\n                          PC1    PC2     PC3     PC4\nStandard deviation     1.6594 0.8789 0.60435 0.32938\nProportion of Variance 0.6884 0.1931 0.09131 0.02712\nCumulative Proportion  0.6884 0.8816 0.97288 1.00000\n```\n:::\n:::\n\n\nPC1 explains 68.8% of the variation and PC2 explains 19.3%\n\n\n::: {.cell}\n\n```{.r .cell-code}\npca <-\n  pca +\n  labs(x = \"PC1 (68.6%)\",\n       y = \"PC2 (19.3%)\")\n\npca\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nNext, there are two methods commonly used to show groupings/separation on score plots: convex hulls and confidence ellipses.\nA convex hull is simply a convex polygon drawn around all the points in a group---it doesn't have any statistical interpretation, but it can aid visualization in busy plots.\nA `stat_chull()` is available in the `ggpubr` package that makes this easy.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggpubr)\npca + stat_chull(geom = \"polygon\", aes(fill = species), alpha = 0.3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n`geom = \"polygon\"` is necessary, otherwise it will draw a line that's not connected at the ends.\nHere I'm setting the fill the same as the points and making it transparent so you can see the points underneath (and overlap of the hulls).\nThis is a bit redundant, but we could use a hull to represent something different---island for example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(scores_data, aes(x = PC1, y = PC2, shape = species)) +\n  geom_point() +\n  stat_chull(geom = \"polygon\", aes(fill = island, linetype = island), color = \"black\", alpha = 0.3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nThe other common way to show grouping is with confidence ellipses.\n95% confidence ellipses can be added with `stat_ellipse()` from `ggplot2`.\nThese ellipses do at least imply some statistical meaning, and may not be appropriate for every method.\nFor example, you cannot say that groups are statistically different based on ellipses in a PLS score plot!\nSee [this previous post](https://www.ericrscott.com/post/cupcakes-vs-muffins-round-2/) for why.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npca + stat_ellipse()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n### Loading Plot\n\nThe loading plot is a little more complicated to make, since it usually involves drawing arrows from 0,0 out to the value to indicate how variables are \"loaded\" onto the axes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloadings <- as_tibble(out_prcomp$rotation, rownames = \"var\")\nloadings\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  var                  PC1      PC2    PC3    PC4\n  <chr>              <dbl>    <dbl>  <dbl>  <dbl>\n1 bill_length_mm     0.455 -0.597   -0.644  0.146\n2 bill_depth_mm     -0.400 -0.798    0.418 -0.168\n3 flipper_length_mm  0.576 -0.00228  0.232 -0.784\n4 body_mass_g        0.548 -0.0844   0.597  0.580\n```\n:::\n:::\n\n\nTo start, I'll use `geom_segment()` for the arrows.\nThe default arrows are too big, so I'll adjust them with arguments to `arrow()`.\nI'll also add the same axis labels right away.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npca_load <- \n  ggplot(loadings) +\n  geom_segment(aes(x = 0, y = 0, xend = PC1, yend = PC2), \n               arrow = arrow(length = unit(0.025, \"npc\"))) +\n  labs(x = \"PC1 (68.6%)\",\n       y = \"PC2 (19.3%)\")\npca_load\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nNow I'll add the labels.\nI like to use the `ggrepel` package for this, as it automatically moves the labels away from the arrows without having to mess with adjusting them manually.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggrepel)\npca_load <- \n  pca_load +\n  geom_label_repel(aes(x = PC1, y = PC2, label = var), point.padding = 10, min.segment.length = 0)\npca_load\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nIn the past when I've had to plot more crowded loading plots, I've done some complicated adjusting of the coordinates for the labels so that they always tend to be \"in front\" of the arrows.\nYou can see an example of this [here](https://github.com/Aariq/BACE-legacy-effects/blob/5fbeb41de44023393cac35b13a465e27db5bb000/R/plot_rda.R#L33).\n\nThe score and loading plots are easier to interpret side by side if the center is at the same point.\nThe easiest way to do that is to force the axes to by symmetrical and centered at zero.\nThere's a `symmetric_limits` function avialable in the `ggpmisc` package that works well for this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggpmisc)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: ggpp\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'ggpp'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:ggplot2':\n\n    annotate\n```\n:::\n\n```{.r .cell-code}\npca <-\n  pca +\n  scale_x_continuous(limits = symmetric_limits) + \n  scale_y_continuous(limits = symmetric_limits)\npca_load <-\n  pca_load + \n  scale_x_continuous(limits = symmetric_limits) +\n  scale_y_continuous(limits = symmetric_limits)\n\npca\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n```{.r .cell-code}\npca_load\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-2.png){width=672}\n:::\n:::\n\n\nAnd I'll just finish it up a bit...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork) #for multipanel figures\n(pca + stat_ellipse()) /\npca_load &\n  theme_bw() &\n  plot_annotation(tag_levels = \"a\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n## With vegan::rda()\n\nBecause not all packages output scores and loadings the same way, you might need to do some digging to find thes data.\nFor example, for objects created by `rda()` from the `vegan` package, you can actually get the data you need from saving the results of `plot()`.\nIn this case, the `plot()` method is silently returning the data used to make the plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vegan)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: permute\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: lattice\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThis is vegan 2.6-4\n```\n:::\n\n```{.r .cell-code}\nout_rda <- rda(scale(X))\nx <- plot(out_rda)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n```{.r .cell-code}\nx$species #loadings\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                        PC1          PC2\nbill_length_mm     2.295549 -1.594500048\nbill_depth_mm     -2.018643 -2.130607173\nflipper_length_mm  2.904483 -0.006095108\nbody_mass_g        2.764994 -0.225309318\n```\n:::\n\n```{.r .cell-code}\nhead(x$sites) #scores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            PC1           PC2\nsit1 -0.3650548 -0.0178350837\nsit2 -0.2587762  0.1601524451\nsit3 -0.2711370  0.0577562149\nsit4 -0.3720614  0.0007658659\nsit5 -0.3785807 -0.3100279921\nsit6 -0.3491294  0.1314125112\n```\n:::\n:::\n\n\nOnce you've identified the score and loading data, you can use the same methods above to make your customizable plot.\n\n\n{{< downloadthis index.Rmd dname=\"index.Rmd\" label=\"Download Rmd\" >}}\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}