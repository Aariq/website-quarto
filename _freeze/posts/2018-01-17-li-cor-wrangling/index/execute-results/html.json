{
  "hash": "1b15be804e838688cf8d0629309f77a4",
  "result": {
    "markdown": "---\ntitle: Importing data from a LI-COR photosynthesis meter into R\n# author: Eric R. Scott\ndate: '2018-01-17'\n# slug: li-cor-wrangling\ncategories:\n  - data-science\n  - r\n  - data-wrangling\n  - regexp\n\n# projects: [\"bace-tea\"]\n \nimage: featured.png\nimage-alt: \"A graphical representation of a data wrangling workflow.  An arrow points from a licor photosynthesis meter to a text file and another arrow points from the text file to a cleaned dataset\"\n---\n\n\n\n\nThe [LI-6400XT](https://www.licor.com/env/products/photosynthesis/LI-6400XT/) is a portable device used to measure photosynthesis in plant leaves.\nAs you take measurements by pressing a button on the device, they are recorded into memory.\nIn order to keep track of which measurments go with which plants (or experimental treatments), there is an \"add remark\" option where you can enter sample information before taking measurements.\n\nWhen the data are exported, you get a series of .xls files and a plain text file.\nBoth of these have some problems that you'll have to deal with if you want to read the data into R and use it for statistical analysis or generating reports.\n\n![Excel nightmare or text nightmare? Pick your poison.](licor_excel.png){fig-alt=\"On the left, a messy looking text file with xml tags taking up the top two thirds of the screen.  On the right, an excel spreadsheet with metadata in the top 7 rows, two rows of header columns, and \\\"remark\\\" rows interspersed with the actual data\" fig-align=\"center\" width=\"645\"}\n\nBoth file types create some problems for easily getting the data into R:\n\n1.  **Header information** interrupts the data table format. Fortunately, it's mostly just information about the instrument configuration that we don't need.\n2.  **Untidy handling of remarks**. Instead of remarks being in their own column, they appear in the `HHMMSS` column in the .xls files and in the `Obs` column in the .txt file! And to indicate that the row is a remark, instead of giving it an observation number in `Obs`, it just says \"Remark =\".\n3.  **Column headers are spread over two rows**. There is a (somewhat mysterious to me) row of \"in\"s and \"out\"s under the column headers in the .xls file.\n4.  Another problem that you can't see in Fig. 1 is that I've done my measurements **in several bouts**. This produced two .xls files and a text file with header text in-between my two sets of measurements.\n\nAt this point I had to choose between reading in the .xls files with `read_xls()` from the `readxl` package and doing some wrangling from there, or to deal with the text file, which would surely include some regular expression headaches.\n\nFor some unknown reason, `read_xls()` didn't work on these files, and I had to open them in Excel, then save them as .xlsx files and use `read_xlsx()` to get them into R.\nFor the sake of full automatedness, I'm going to work through the text file example here.\n\n## Tidying up raw text\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"grViz html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-435b4b8a3b9df34f4fe2\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-435b4b8a3b9df34f4fe2\">{\"x\":{\"diagram\":\"digraph rmarkdown {\\n        \\n        graph [layout = dot, rankdir = TB, fontsize = 16]\\n        # node definitions with substituted label text\\n        node [fontname = Avenir, shape = rectangle]        \\n        rec1 [label = \\\"Raw text\\\"]\\n        rec2 [label = \\\"List of strings\\\"]\\n        rec3 [label = \\\"List of data frames\\\"]\\n        rec4 [label = \\\"Extract sample ID\\nfrom remarks\\\"]\\n\\n        node [fontname = Avenir, shape = oval]\\n        ova1 [label = \\\"Tidy and split\\\"]\\n\\n        node [fontname = Courier, shape = oval]\\n        ova2 [label = \\\"map(list, read_tsv)\\\"]\\n        ova3 [label = \\\"bind_rows()\\\"]\\n\\n        # edge definitions with the node IDs\\n        rec1 -> ova1 -> rec2 -> ova2 -> rec3 -> ova3 -> rec4\\n  }\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n\nMy approach to wrangling text files generated by the LI-6400XT\n:::\n:::\n\n\nMy approach is to read in the raw text, tidy it up, then use `read_tsv()` to get a list of data frames.\nAfter that, I planned to combine them into one big data frame and do some more tidying to extract the sample IDs from the remarks.\nI'll be using functions from `stringr` to do the text tidying, and functions from various `tidyverse` packages to bring it all together into a coherent data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(stringr)\nlibrary(here)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntext.raw <- read_file(\"licor.txt\")\n```\n:::\n\n\nScrolling through the text a little reveals that, conveniently, the line `\"$STARTOFDATA$\"` appears between the header information and the start of the actual data.\nThe headers themselves always begin with `\"OPEN\"` followed by a date.\nI created regular expression patterns for these and used them to split the raw text file first into separate bouts of measurements, then into headers and data, discarding the headers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheader_pattern <- \"\\\"OPEN \\\\d\\\\.\\\\d\\\\.\\\\d\"\ndata_pattern <- \"\\\\$STARTOFDATA\\\\$\"\n\n#splits into individual bouts\nraw_split <- str_split(text.raw, header_pattern, simplify = TRUE)\n\n#splits further to separate headers from actual data\nraw_split2 <- str_split(raw_split, data_pattern, simplify = FALSE)\n\nstr(raw_split2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ : chr \"\"\n $ : chr [1:2] \"\\\"\\n\\\"Fri Aug 25 2017 08:29:30\\\"\\n<open><version>\\\"6.3.4\\\"</version></open>\\n<open><configfile>\\\"/User/Configs/\"| __truncated__ \"\\n\\\"Obs\\\"\\t\\\"HHMMSS\\\"\\t\\\"FTime\\\"\\t\\\"EBal?\\\"\\t\\\"Photo\\\"\\t\\\"Cond\\\"\\t\\\"Ci\\\"\\t\\\"Trmmol\\\"\\t\\\"VpdL\\\"\\t\\\"CTleaf\\\"\\t\\\"A\"| __truncated__\n $ : chr [1:2] \"\\\"\\n\\\"Fri Aug 25 2017 10:32:44\\\"\\n<open><version>\\\"6.3.4\\\"</version></open>\\n<open><configfile>\\\"/User/Configs/\"| __truncated__ \"\\n\\\"Obs\\\"\\t\\\"HHMMSS\\\"\\t\\\"FTime\\\"\\t\\\"EBal?\\\"\\t\\\"Photo\\\"\\t\\\"Cond\\\"\\t\\\"Ci\\\"\\t\\\"Trmmol\\\"\\t\\\"VpdL\\\"\\t\\\"CTleaf\\\"\\t\\\"A\"| __truncated__\n```\n:::\n:::\n\n\nIt's a little hard to see here, but now there is a list of 3 elements.\nThe first element contains nothing (because there is nothing before the first `header_pattern`), the other elements contain two strings---one is the header, the other is the data.\nLet's get rid of the headers and the empty list element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract just the second element, the actual data\nraw_split3 <- raw_split2 %>%\n  map(`[`, 2) %>% #equivalent to doing raw_split2[[i]][2] for every element \"i\"\n  flatten_chr() #converts to a vector\n\n#remove empty elements\nraw_split3 <- raw_split3[!is.na(raw_split3)]\n```\n:::\n\n\n## Reading in our cleaned text file\n\nThen we can finally read in our cleaned text as a tab-separated (.tsv) file.\nHere I make use of `map()` from the `purrr` package to apply `read_tsv()` to every string in our raw text vector.\n`skip = 1` gets rid of that weird line of \"in\"s and \"out\"s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- raw_split3 %>%\n  map( ~ read_tsv(\n    .x,\n    col_types = cols(\n      .default = col_double(),\n      Obs = col_character(),\n      HHMMSS = col_time(format = \"\")\n    )\n  ), skip = 1)\n\n# input.all <- bind_rows(input) #not working. Says cols are different types, but that can't be true!\ninput.all <- rbind(input[[1]], input[[2]])\nhead(input.all, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 40\n   Obs      HHMMSS   FTime `EBal?` Photo    Cond    Ci Trmmol  VpdL CTleaf  Area\n   <chr>    <time>   <dbl>   <dbl> <dbl>   <dbl> <dbl>  <dbl> <dbl>  <dbl> <dbl>\n 1 08:30:3…       NA    NA      NA NA    NA         NA NA     NA      NA      NA\n 2 08:32:3…       NA    NA      NA NA    NA         NA NA     NA      NA      NA\n 3 08:40:2…       NA    NA      NA NA    NA         NA NA     NA      NA      NA\n 4 08:40:2…       NA    NA      NA NA    NA         NA NA     NA      NA      NA\n 5 08:40:2…       NA    NA      NA NA    NA         NA NA     NA      NA      NA\n 6 08:40:2…       NA    NA      NA NA    NA         NA NA     NA      NA      NA\n 7 08:42:1…       NA    NA      NA NA    NA         NA NA     NA      NA      NA\n 8 08:43:1…       NA    NA      NA NA    NA         NA NA     NA      NA      NA\n 9 1        08:43:53   932       0  6.62  0.0589   202  0.724  1.25   22.3     6\n10 2        08:43:58   937       0  6.99  0.0594   193  0.731  1.25   22.3     6\n# … with 29 more variables: BLC_1 <dbl>, StmRat <dbl>, BLCond <dbl>,\n#   Tair <dbl>, Tleaf <dbl>, TBlk <dbl>, CO2R <dbl>, CO2S <dbl>, H2OR <dbl>,\n#   H2OS <dbl>, RH_R <dbl>, RH_S <dbl>, Flow <dbl>, PARi <dbl>, PARo <dbl>,\n#   Press <dbl>, CsMch <dbl>, HsMch <dbl>, CsMchSD <dbl>, HsMchSD <dbl>,\n#   CrMchSD <dbl>, HrMchSD <dbl>, StableF <dbl>, BLCslope <dbl>,\n#   BLCoffst <dbl>, f_parin <dbl>, f_parout <dbl>, alphaK <dbl>, Status <dbl>\n```\n:::\n:::\n\n\n## Extracting useful remarks\n\nThe first step is moving remarks into a `remark` column while keeping the observation numbers in the `Obs` column.\nI'm sure there is a more elegant way to do this, but I had recently [learned about](http://purrr.tidyverse.org/reference/safely.html) the `safely()` function from `purrr` which allows you to capture errors.\nI figured I could try converting elements of the `Obs` column to integers and if it failed, I could use that as a criteria for moving to a new column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a \"safe\" version of as.integer() that returns a list of a result and error\nsafe_as.int <- safely(as.integer)\n#returns error for text remarks, returns value for integer observation numbers\n\ninput.all <- input.all %>% \n  mutate(#create a comment column to indicate if an \"Obs\" is actually a remark\n       comment = is.na(safe_as.int(Obs)$result), \n       #copy those remarks to the remark column\n       remark = ifelse(comment == TRUE, Obs, NA),\n       #remove remarks from Obs column\n       Obs = ifelse(comment == FALSE, Obs, NA)) %>% \n#move the remark column the the begining\nselect(remark, everything()) %>% \n#remove the comment column.  We're done with it\nselect(-comment)\nhead(input.all, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 41\n   remark   Obs   HHMMSS   FTime `EBal?` Photo    Cond    Ci Trmmol  VpdL CTleaf\n   <chr>    <chr> <time>   <dbl>   <dbl> <dbl>   <dbl> <dbl>  <dbl> <dbl>  <dbl>\n 1 08:30:3… <NA>        NA    NA      NA NA    NA         NA NA     NA      NA  \n 2 08:32:3… <NA>        NA    NA      NA NA    NA         NA NA     NA      NA  \n 3 08:40:2… <NA>        NA    NA      NA NA    NA         NA NA     NA      NA  \n 4 08:40:2… <NA>        NA    NA      NA NA    NA         NA NA     NA      NA  \n 5 08:40:2… <NA>        NA    NA      NA NA    NA         NA NA     NA      NA  \n 6 08:40:2… <NA>        NA    NA      NA NA    NA         NA NA     NA      NA  \n 7 08:42:1… <NA>        NA    NA      NA NA    NA         NA NA     NA      NA  \n 8 08:43:1… <NA>        NA    NA      NA NA    NA         NA NA     NA      NA  \n 9 <NA>     1     08:43:53   932       0  6.62  0.0589   202  0.724  1.25   22.3\n10 <NA>     2     08:43:58   937       0  6.99  0.0594   193  0.731  1.25   22.3\n# … with 30 more variables: Area <dbl>, BLC_1 <dbl>, StmRat <dbl>,\n#   BLCond <dbl>, Tair <dbl>, Tleaf <dbl>, TBlk <dbl>, CO2R <dbl>, CO2S <dbl>,\n#   H2OR <dbl>, H2OS <dbl>, RH_R <dbl>, RH_S <dbl>, Flow <dbl>, PARi <dbl>,\n#   PARo <dbl>, Press <dbl>, CsMch <dbl>, HsMch <dbl>, CsMchSD <dbl>,\n#   HsMchSD <dbl>, CrMchSD <dbl>, HrMchSD <dbl>, StableF <dbl>, BLCslope <dbl>,\n#   BLCoffst <dbl>, f_parin <dbl>, f_parout <dbl>, alphaK <dbl>, Status <dbl>\n```\n:::\n:::\n\n\nIn the data frame above, you'll notice that some of the remarks are just me changing parameters of the device, while others are sample IDs (e.g. \"08:43:13 c 4 a\" is plot c, plant 4, leaf a).\nI got lucky in my sample naming convention in that the sample IDs are relatively easily distinguishable from other remarks using regular expressions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#you must replace NA with the literal string \"NA\" so str_* functions from stringr can deal with it\ninput.all <- input.all %>% mutate(remark = str_replace_na(remark))\n\nIDpattern <- \"[:lower:][:blank:]\\\\d+[:blank:][:lower:]\"\nstr_view(input.all$remark[1:10], IDpattern)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[8] │ 08:43:13 <c 4 a>\n```\n:::\n:::\n\n\nNow that I've figure out a pattern that matches the ID's I can use `str_extract()` to move them to a new `sampleID` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput.all <- input.all %>%\n  mutate(sampleID = str_extract(remark, IDpattern)) %>% \n  select(sampleID, everything())\nhead(input.all, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 42\n   sampleID remark Obs   HHMMSS   FTime `EBal?` Photo    Cond    Ci Trmmol  VpdL\n   <chr>    <chr>  <chr> <time>   <dbl>   <dbl> <dbl>   <dbl> <dbl>  <dbl> <dbl>\n 1 <NA>     08:30… <NA>        NA    NA      NA NA    NA         NA NA     NA   \n 2 <NA>     08:32… <NA>        NA    NA      NA NA    NA         NA NA     NA   \n 3 <NA>     08:40… <NA>        NA    NA      NA NA    NA         NA NA     NA   \n 4 <NA>     08:40… <NA>        NA    NA      NA NA    NA         NA NA     NA   \n 5 <NA>     08:40… <NA>        NA    NA      NA NA    NA         NA NA     NA   \n 6 <NA>     08:40… <NA>        NA    NA      NA NA    NA         NA NA     NA   \n 7 <NA>     08:42… <NA>        NA    NA      NA NA    NA         NA NA     NA   \n 8 c 4 a    08:43… <NA>        NA    NA      NA NA    NA         NA NA     NA   \n 9 <NA>     NA     1     08:43:53   932       0  6.62  0.0589   202  0.724  1.25\n10 <NA>     NA     2     08:43:58   937       0  6.99  0.0594   193  0.731  1.25\n# … with 31 more variables: CTleaf <dbl>, Area <dbl>, BLC_1 <dbl>,\n#   StmRat <dbl>, BLCond <dbl>, Tair <dbl>, Tleaf <dbl>, TBlk <dbl>,\n#   CO2R <dbl>, CO2S <dbl>, H2OR <dbl>, H2OS <dbl>, RH_R <dbl>, RH_S <dbl>,\n#   Flow <dbl>, PARi <dbl>, PARo <dbl>, Press <dbl>, CsMch <dbl>, HsMch <dbl>,\n#   CsMchSD <dbl>, HsMchSD <dbl>, CrMchSD <dbl>, HrMchSD <dbl>, StableF <dbl>,\n#   BLCslope <dbl>, BLCoffst <dbl>, f_parin <dbl>, f_parout <dbl>,\n#   alphaK <dbl>, Status <dbl>\n```\n:::\n:::\n\n\n## Fill down\n\nNow, if this were Excel, you could highlight that \"c 4 a\" and drag the corner down to fill in all the NA's.\nIn R, you can do exactly this with the `fill()` function from `tidyr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#get rid of other remarks and fill down the sample ID column\noutput <- input.all %>% \n  filter(!xor(remark == \"NA\" , is.na(sampleID))) %>%\n  fill(sampleID) %>% \n  #get rid of the rest of the remark rows\n  filter(complete.cases(.)) %>% \n  #get rid of the remark column\n  select(-remark)\nhead(output, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 41\n   sampleID Obs   HHMMSS   FTime `EBal?` Photo   Cond    Ci Trmmol  VpdL CTleaf\n   <chr>    <chr> <time>   <dbl>   <dbl> <dbl>  <dbl> <dbl>  <dbl> <dbl>  <dbl>\n 1 c 4 a    1     08:43:53   932       0  6.62 0.0589   202  0.724  1.25   22.3\n 2 c 4 a    2     08:43:58   937       0  6.99 0.0594   193  0.731  1.25   22.3\n 3 c 4 a    3     08:44:03   942       0  6.96 0.0596   195  0.731  1.25   22.3\n 4 c 4 b    4     08:44:39   978       0  7.08 0.0783   237  0.941  1.23   22.4\n 5 c 4 b    5     08:44:46   985       0  6.9  0.0791   242  0.949  1.23   22.4\n 6 c 4 b    6     08:44:51   990       0  6.78 0.0801   246  0.959  1.22   22.4\n 7 c 4 c    7     08:45:31  1030       0  6.34 0.0654   228  0.805  1.25   22.4\n 8 c 4 c    8     08:45:38  1037       0  6.48 0.0648   222  0.798  1.26   22.5\n 9 c 4 c    9     08:45:45  1044       0  6.51 0.0664   226  0.819  1.26   22.5\n10 c 4 c    10    08:45:51  1050       0  6.68 0.0678   225  0.836  1.26   22.5\n# … with 30 more variables: Area <dbl>, BLC_1 <dbl>, StmRat <dbl>,\n#   BLCond <dbl>, Tair <dbl>, Tleaf <dbl>, TBlk <dbl>, CO2R <dbl>, CO2S <dbl>,\n#   H2OR <dbl>, H2OS <dbl>, RH_R <dbl>, RH_S <dbl>, Flow <dbl>, PARi <dbl>,\n#   PARo <dbl>, Press <dbl>, CsMch <dbl>, HsMch <dbl>, CsMchSD <dbl>,\n#   HsMchSD <dbl>, CrMchSD <dbl>, HrMchSD <dbl>, StableF <dbl>, BLCslope <dbl>,\n#   BLCoffst <dbl>, f_parin <dbl>, f_parout <dbl>, alphaK <dbl>, Status <dbl>\n```\n:::\n:::\n\n\nAnd finally, we have a cleaned data frame ready for use in analyses!\nYou could go on to separate plot ID, plant ID and leaf ID using `separate()` from `tidyr`, and then do any necessary calculations, visualizations, and modeling with the resulting data frame.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.1/htmlwidgets.js\"></script>\n<script src=\"../../site_libs/viz-1.8.2/viz.js\"></script>\n<link href=\"../../site_libs/DiagrammeR-styles-0.2/styles.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/grViz-binding-1.0.9/grViz.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}