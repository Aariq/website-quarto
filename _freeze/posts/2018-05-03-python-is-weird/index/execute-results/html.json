{
  "hash": "dadef22210266a78860e7b446c514896",
  "result": {
    "markdown": "---\ntitle: Python is Weird (an unabashedly biased intro to Python for R users)\n# author: Eric R. Scott\ndate: '2018-05-03'\n# slug: python-is-weird\ncategories:\n  - data-science\n  - python\n  - r\nimage: featured.png\nimage-alt: \"Meme of line drawing of Jackie Chan looking confused/angry next to a Python logo\"\n---\n\n\n\n\nLast semester I took a class that used Python.\nIt was my first time really seriously using any programing language other than R.\nThe students were about half engineers and half biologists.\nThe vast majority of the biologists knew R to varying degrees, but had no experience with Python, and the engineers seemed to generally have some experience with Python, or at least with languages more similar to it than R.\nI wish that the instructor could have taught every Python lecture like \"Ok, today we're going to learn the Python equivalent of doing \\_\\_\\_\\_ in R\", but of course that wouldn't be fair to about half the students.\n\nSo for anyone else making the leap from R to Python, here are three things that are going to feel really weird about Python.\n\n# 1. Indexing is not intuitive in Python\n\nLet me just show you first and see if you can figure out what is going on:\n\n*R Code:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R\nx = c(10, 20, 30, 40, 50)\nx[1]\nx[1:3]\nx[4:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n[1] 10 20 30\n[1] 40 50\n```\n:::\n:::\n\n\nCool, cool.\n\n*Equivalent in Python:*\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Python\nx = [10, 20, 30, 40, 50]\nprint(x[1])\nprint(x[0])\nprint(x[3:4])\nprint(x[3:5])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n20\n10\n[40]\n[40, 50]\n```\n:::\n:::\n\n\nWait, what?\nTwo things are really weird about this.\nFirst, the first position in the vector is not position 1, it is position 0.\nSecond, `x[3:4]` returns only a single number.\nWhy?!\nBecause in Python, the second number in the index is not inclusive, so if you want to get the 4th and 5th values of `x` (index positions 3 and 4 in Python world), then you have to use `x[3:5]` **even though there is NO POSITION 5**.\nTerrible.\n\n*Weird thing 1.1: Python is much more geared toward writing programs than R. That means you can't really run python code one line at a time like R and you have to explicitly `print()` things that you want to be output to the screen.*\n\n# 2. You need to load a package just to do vector math\n\nR is built for doing math and statistics, so vectors and matrices are built in and you can do math on them!\n\n*R Code:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R\nx = c(1, 2, 3)\nx + 10\nx * 2\ny = c(5, 6, 7)\nx + y\n#Yay vector arithmetic!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11 12 13\n[1] 2 4 6\n[1]  6  8 10\n```\n:::\n:::\n\n\nPython is **not** built with math and statistics in mind, and this doesn't work without using a package.\n\n*Equivalent in Python:*\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Python\nx = [1, 2, 3]\nprint(x + [10]) \nprint(x*3) \ny = [5, 6, 7]\nprint(x + y) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 10]\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n[1, 2, 3, 5, 6, 7]\n```\n:::\n:::\n\n\nClearly `+` is doing something different in base Python---it's concatenating `x` and `10`.\nSimilarly, `*` is not multiplying, but concatenating three `x`s in a row.\nThis is completely ridiculous behavior for numbers, but when you're working with strings, it's actually pretty freakin' great.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Python\nprint((\"Yay \"+\"Python! \") * 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nYay Python! Yay Python! Yay Python! Yay Python! Yay Python! \n```\n:::\n:::\n\n\nIf you want numerical vectors to work like they should, you have to use a special kind of vector called a **numpy array**.\nNumpy is a package for Python that provides a bunch of functions that work on numbers.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Python\nimport numpy as np\nx = np.array([1, 2, 3])\nprint(x + 10)\nprint(x * 2) \ny = np.array([5, 6, 7])\nprint(x + y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[11 12 13]\n[2 4 6]\n[ 6  8 10]\n```\n:::\n:::\n\n\nIf you do math to numpy arrays, you get what you'd expect as an R user.\n\n*Wierd thing 2.1: note that the `packagename.function()` form is equivalent to `packagename::function()` in R, but unlike R, it is always required. That is, as far as I know, there is nothing you can do to make `array([1,2,3])` work without the preceding `np.`*\n\n# 3. Default assignment behavior is aliasing\n\nI'm still trying to wrap my mind around this one, so rather than trying to explain it, let me show you an example first:\n\n*R Code:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R\na1 = c(1,2,3)\na2 = a1\na2[1] = 100\na1\na2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n[1] 100   2   3\n```\n:::\n:::\n\n\n`a1` is, of course, unchanged by changing a value in `a2`.\nLet's see if that's true in Python.\n\n*Equivalent in Python:*\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Python\nimport numpy as np\na1 = np.array([1,2,3])\na2 = a1\na2[1] = 100\nprint(a1)\nprint(a2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[  1 100   3]\n[  1 100   3]\n```\n:::\n:::\n\n\nChanging a value in `a2` *changes* the same value in `a1`!\nIn this case, `a2` is an *alias* of `a1`, not a copy.\nThis only happens when you do `object1 = object2` and not when you do something to `object2` as you're assigning it.\nHere's another example:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Python\nimport numpy as np\na1 = np.array([1,2,3])\na2 = a1 + 2\na2[1] = 100\nprint(a1)\nprint(a2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3]\n[  3 100   5]\n```\n:::\n:::\n\n\nNow `a2` is a separate object from `a1` instead of just an alias.\nIf you want to make an *exact* copy, you have to do that explicitly with `a2 = np.copy(a1)` or `a2 = a1[:]`\n\n# Try Python!\n\nAs many people in the data science world have pointed out, it's not R vs. Python, it's [R *and* Python](https://www.datasciencecentral.com/profiles/blogs/r-vs-python-r-and-python-and-something-else).\nFrom my limited experience, the benefits of Python over R I've are that it seems to be faster, defining classes and functions seems less painful, and it's great at working with strings out of the box.\nI don't really plan on working in Python more unless I have to, but knowing a bit of the language will be useful for talking shop with people who use it!\n\n\n{{< downloadthis index.Rmd dname=\"index.Rmd\" label=\"Download Rmd\" >}}\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}